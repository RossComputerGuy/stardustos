/** \file include/newland/dev.h
 * \author Tristan Ross
 * \copyright GNU Public License 3.0
 * \brief Device and device driver API
 * \since v0.1.0
 * \details Also known as the central device API, this portion of the kernel controls all device drivers on the system.
 */
#pragma once

#include <newland/fs.h>
#include <sys/types.h>
#include <liblist.h>

/**
 * Extracts the major value from a device value
 *
 * @param[in] dev The device value
 * @return The major value as an int
 */
#define DEV_MAJOR(dev) ((dev) >> 8)

/**
 * Extracts the minor value from a device value
 *
 * @param[in] dev The device value
 * @return The minor value as an int
 */
#define DEV_MINOR(dev) ((dev) & 0xFF)

/**
 * Combines a major and minor into a device value
 *
 * @param[in] ma The major value
 * @param[in] mi The minor value
 * @return A device value
 */
#define MKDEV(ma, mi) ((ma) << 8 | (mi))

/**
 * The major value of a block device
 */
#define DEVMAJ_BLOCK 1

/**
 * The major value of a TTY
 */
#define DEVMAJ_TTY 2

/**
 * The major value of a multiboot module
 */
#define DEVMAJ_MBMOD 3

/**
 * Device driver structure, this represents both a device and a driver for that device
 */
typedef struct device {
	SLIST_ENTRY(struct device) dev_list;
	SLIST_ENTRY(struct device) bus_list;

	/**
	 * The device's device value generated by MKDEV
	 */
	dev_t dev;

	/**
	 * The size in bytes the device node is
	 */
	size_t size;

	/**
	 * The name of the device
	 */
	const char name[NAME_MAX];

	/**
	 * File Node Operations, used for controling a device node with the filesystem functions
	 */
	fs_node_opts_t opts;
} device_t;

/**
 * Get the number of registered devices
 *
 * @return A number
 */
size_t device_count();

/**
 * Gets the index of the device in the registered devices list
 *
 * @return An index the device is at or -1 if it didn't find the device in the registered devices list
 */
size_t device_indexof(device_t* device);

/**
 * Get a device by its index
 *
 * @return A device or NULL if it cannot be found
 */
device_t* device_get(size_t i);

/**
 * Gets a device by its device value
 *
 * @return A device or NULL if it cannot be found
 */
device_t* device_fromdev(dev_t dev);

/**
 * Gets a device by its name
 *
 * @return A device or NULL if it cannot be found
 */
device_t* device_fromname(const char* name);

/**
 * Registers a device
 *
 * @param[in] dev The device value, if the device value has been used before then it'll fail to register
 * @param[in] name The name of the device, if the name has already been used then the device will fail to register
 * @param[in] opts The filesystem node operations, used by the filesystem functions for controlling the device
 * @param[in] size The filesystem node size, used by the filesystem
 * @return Zero on success or a negative errno code
 */
int register_device(dev_t dev, const char* name, fs_node_opts_t opts, size_t size);

/**
 * Unregisters a device
 *
 * @todo Possibly add a function pointer for the device to free the resources its used when this function is called
 * @param[in] dev The device value, if the device value has never been used then it'll fail to unregister
 * @return Zero on success or a negative errno code
 */
int unregister_device(dev_t dev);